import os
import re
import subprocess
import json
from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel
import httpx
from bs4 import BeautifulSoup
import logging

# --- Configuration ---
AIPROXY_URL = "https://aiproxy.sanand.workers.dev/openai/v1/chat/completions"
OPENAI_BASE_URL = "https://aipipe.org/openrouter/v1/chat/completions"
MAX_EXECUTION_RETRIES = 3

# --- Logging Setup ---
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- FastAPI App Initialization ---
app = FastAPI(
    title="Multi-Agent Data Analyst",
    description="A multi-agent system that uses a pipeline of specialized LLMs to answer data analysis questions.",
)

# --- AGENT PROMPTS ---

# Stage 1: Planner Agent
PLANNER_SYSTEM_PROMPT = """
You are a lead data analyst responsible for planning tasks. Based on the user's request, create a clear, step-by-step plan and identify all necessary Python libraries to be installed via pip.
Your output MUST be a single, valid JSON object with two keys: "plan" and "libraries".
- "plan": A list of strings, where each string is a logical step in the analysis.
- "libraries": A list of strings for pip to install (e.g., "pandas", "duckdb"). Do NOT include standard libraries that are built into Python (e.g., json, re, base64, os).
"""

# Stage 2: Validator Agent
VALIDATOR_SYSTEM_PROMPT = """
You are a meticulous and skeptical Lead Analyst responsible for quality control. Your task is to critique and validate a plan created by another agent.
Review the provided plan and list of libraries. Check for:
- Logical errors or missing steps (e.g., forgetting a data cleaning step).
- Inefficiencies or better ways to perform a task.
- Mismatches between the plan and the required libraries.
Your output MUST be a single, valid JSON object in the SAME FORMAT as the input, with your corrections or improvements. If the plan is perfect, return it unchanged.
"""

# Stage 3: Coder Agent
CODER_SYSTEM_PROMPT = """
You are an expert Python coder. Your goal is to write a complete, self-contained Python script to execute the provided plan.

**CORE DIRECTIVES:**
1.  **Follow the Plan**: Implement the validated, step-by-step plan exactly.
2.  **Be Robust**: Write clean, efficient code. For file paths, especially S3, use wildcards as shown in user prompts and filter with WHERE clauses; do not hardcode example paths.

**CODE GENERATION RULES:**
* You MUST write a single, runnable Python script enclosed in a markdown block: ```python\n...code...\n```.

**CRITICAL OUTPUT RULE:**
* Your script's final action MUST be a single `print(json.dumps(final_answer))` statement.
* **Infer the JSON structure from the user's original request.**
* **NEVER return a JSON object containing an 'error' key.** Let the script fail with an exception if an unrecoverable error occurs.
"""

# Stage 4: Critic Agent
CRITIC_SYSTEM_PROMPT = """
You are an expert Python code reviewer acting as a linter and quality checker. Your task is to review a script generated by another agent BEFORE it is executed.
Analyze the provided Python script for:
- Syntax errors or typos.
- Obvious logical bugs (e.g., using a variable before assignment, incorrect S3 paths).
- Unused imports or missing imports.
- Failure to adhere to the final `print(json.dumps(...))` output format.
Your output MUST be a single JSON object: `{"code_ok": true/false, "corrected_code": "...", "reasoning": "..."}`.
If `code_ok` is true, return the original code in "corrected_code".
If `code_ok` is false, provide the fixed code in "corrected_code" and a brief explanation in "reasoning".
"""

# Stage 6: Debugger Agent
DEBUGGER_PROMPT_TEMPLATE = """
The Python code you previously wrote, based on the user's request, failed during execution. Review the code, the original request, and the runtime error, then provide a corrected version.

**Original User Request:**
{task_description}

**Code That Failed:**
```python
{previous_code}
Runtime Error Message:
{error_message}

Your Task:
Fix the bug in the original code to successfully complete the user's request. Focus on the root cause of the runtime error.

Provide the complete, corrected, and robust Python script below.
"""


# --- Helper Functions ---
def extract_json_object(response_text: str) -> str | None:
    match = re.search(r"{.*}", response_text, re.DOTALL)
    return match.group(0) if match else None


def extract_python_code(response_text: str) -> str | None:
    match = re.search(r"(?:python)?\n(.*?)\n", response_text, re.DOTALL)
    return match.group(1).strip() if match else None


def install_package(package_name: str) -> tuple[bool, str | None]:
    try:
        logger.info(f"Checking/installing package: {package_name}")
        subprocess.run(
            ["python", "-m", "pip", "install", package_name],
            check=True,
            capture_output=True,
            text=True,
            timeout=180,
        )
        return True, None
    except subprocess.CalledProcessError as e:
        error_message = e.stderr.strip()
        logger.error(f"Failed to install {package_name}: {error_message}")
        return False, error_message


def run_code(script: str) -> tuple[str | None, str | None]:
    try:
        result = subprocess.run(
            ["python", "-c", script], capture_output=True, text=True, timeout=120
        )
        if result.returncode != 0:
            return None, result.stderr.strip()
        return result.stdout.strip(), None
    except Exception as e:
        return None, str(e)


async def call_llm(system_prompt: str, user_prompt: str) -> str:
    # aiproxy_token = os.environ.get("AIPROXY_TOKEN")
    aiproxy_token = os.environ.get("OPENAI_API_KEY")

    if not aiproxy_token:
        raise HTTPException(
            status_code=500, detail="AIPROXY_TOKEN environment variable is not set."
        )
    headers = {
        "Authorization": f"Bearer {aiproxy_token}",
        "Content-Type": "application/json",
    }
    payload = {
        "model": "openai/gpt-4.1-nano",
        "messages": [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ],
        "temperature": 0.0,
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                OPENAI_BASE_URL, json=payload, headers=headers, timeout=90
            )
            response.raise_for_status()
            return response.json()["choices"][0]["message"]["content"]
        except (httpx.HTTPStatusError, KeyError, IndexError) as e:
            logger.error(f"LLM API request failed: {e}")
            raise HTTPException(status_code=500, detail=f"LLM API error: {e}")


# --- API Endpoint ---
@app.post("/api/")
async def data_analyst_agent(request: Request):
    form_data = await request.form()
    task_description = (await form_data.get("file").read()).decode("utf-8")
    logger.info(f"Received task: {task_description}")

    # --- STAGE 1: PLANNER AGENT ---
    logger.info("--- Stage 1: Planner ---")
    try:
        plan_response_str = await call_llm(PLANNER_SYSTEM_PROMPT, task_description)
        json_str = extract_json_object(plan_response_str)
        if not json_str:
            raise ValueError("Planner LLM did not return a JSON object.")
        plan_data = json.loads(json_str)
    except (json.JSONDecodeError, ValueError) as e:
        raise HTTPException(status_code=500, detail=f"Planner Agent failed: {e}")

    # --- STAGE 2: VALIDATOR AGENT ---
    logger.info("--- Stage 2: Validator ---")
    try:
        validated_plan_str = await call_llm(
            VALIDATOR_SYSTEM_PROMPT, json.dumps(plan_data, indent=2)
        )
        json_str = extract_json_object(validated_plan_str)
        if not json_str:
            raise ValueError("Validator LLM did not return a JSON object.")
        validated_plan_data = json.loads(json_str)
        plan = validated_plan_data.get("plan", [])
        libraries = validated_plan_data.get("libraries", [])
        if not plan:
            raise ValueError("Validated plan is missing the 'plan' key.")
        logger.info(f"Validated plan: {plan}")
        logger.info(f"Validated libraries: {libraries}")
    except (json.JSONDecodeError, ValueError) as e:
        raise HTTPException(status_code=500, detail=f"Validator Agent failed: {e}")

    # --- STAGE 3: DEPENDENCY INSTALLATION ---
    logger.info("--- Stage 3: Dependency Installation ---")
    if libraries:
        for lib in libraries:
            success, error_msg = install_package(lib)
            if not success and "No matching distribution found" not in (
                error_msg or ""
            ):
                raise HTTPException(
                    status_code=500,
                    detail=f"Failed to install dependency '{lib}': {error_msg}",
                )

    # --- STAGE 4 & 5: CODER & CRITIC AGENTS ---
    logger.info("--- Stage 4 & 5: Coder & Critic ---")
    coder_prompt = f"**Original User Request:**\n{task_description}\n\n**Validated Execution Plan:**\n{json.dumps(plan, indent=2)}"
    llm_response = await call_llm(CODER_SYSTEM_PROMPT, coder_prompt)
    generated_code = extract_python_code(llm_response)
    if not generated_code:
        raise HTTPException(
            status_code=500, detail="Coder Agent failed to generate Python code."
        )

    critic_response_str = await call_llm(CRITIC_SYSTEM_PROMPT, generated_code)
    critic_json = extract_json_object(critic_response_str)
    if not critic_json:
        raise HTTPException(
            status_code=500, detail="Critic Agent failed to return valid JSON."
        )
    critic_data = json.loads(critic_json)
    if not critic_data.get("code_ok", False):
        logger.warning(
            f"Critic Agent found issues: {critic_data.get('reasoning')}. Using corrected code."
        )
        generated_code = critic_data.get("corrected_code", generated_code)
    else:
        logger.info("Critic Agent approved the code.")

    # --- STAGE 6: EXECUTION & DEBUGGING ---
    logger.info("--- Stage 6: Execution & Debugging ---")
    for attempt in range(MAX_EXECUTION_RETRIES):
        logger.info(f"Execution attempt {attempt + 1}/{MAX_EXECUTION_RETRIES}...")
        logger.info(f"Code to execute:\n---\n{generated_code[:500]}...\n---")
        stdout, stderr = run_code(generated_code)
        if stderr:
            logger.error(f"Code execution failed with error:\n{stderr}")
            if attempt == MAX_EXECUTION_RETRIES - 1:
                raise HTTPException(
                    status_code=500,
                    detail={
                        "error": "Agent failed execution after multiple debug attempts.",
                        "last_error": stderr,
                    },
                )
            debugger_prompt = DEBUGGER_PROMPT_TEMPLATE.format(
                task_description=task_description,
                previous_code=generated_code,
                error_message=stderr,
            )
            llm_response = await call_llm(CODER_SYSTEM_PROMPT, debugger_prompt)
            generated_code = extract_python_code(llm_response)
            if not generated_code:
                raise HTTPException(
                    status_code=500, detail="Debugger Agent failed to generate a fix."
                )
            continue

        if not stdout or not stdout.strip():
            logger.error("CRITICAL: Agent script produced empty output.")
            if attempt == MAX_EXECUTION_RETRIES - 1:
                raise HTTPException(
                    status_code=500,
                    detail={"error": "Agent script produced empty output."},
                )
            debugger_prompt = DEBUGGER_PROMPT_TEMPLATE.format(
                task_description=task_description,
                previous_code=generated_code,
                error_message="The script ran without error but produced no output. This is incorrect. It must print a JSON object.",
            )
            llm_response = await call_llm(CODER_SYSTEM_PROMPT, debugger_prompt)
            generated_code = extract_python_code(llm_response)
            if not generated_code:
                raise HTTPException(
                    status_code=500, detail="Debugger Agent failed to fix empty output."
                )
            continue

        try:
            final_result = json.loads(stdout)
            logger.info("Execution successful. Returning final result.")
            return final_result
        except json.JSONDecodeError:
            raise HTTPException(
                status_code=500,
                detail={
                    "error": "Agent script produced malformed JSON.",
                    "output": stdout,
                },
            )

    raise HTTPException(
        status_code=500,
        detail="Agent failed to produce a valid result within the retry loop.",
    )
